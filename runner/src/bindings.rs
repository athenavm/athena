/* automatically generated by rust-bindgen 0.69.4 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " The ATHCON ABI version number of the interface declared in this file.\n\n The ATHCON ABI version always equals the major version number of the ATHCON project.\n The Host SHOULD check if the ABI versions match when dynamically loading VMs."]
pub const ATHCON_ABI_VERSION: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " The fixed size array of 32 bytes.\n\n 32 bytes of data capable of storing e.g. 256-bit hashes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct athcon_bytes32 {
    #[doc = " The 32 bytes."]
    pub bytes: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_athcon_bytes32() {
    const UNINIT: ::std::mem::MaybeUninit<athcon_bytes32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<athcon_bytes32>(),
        32usize,
        concat!("Size of: ", stringify!(athcon_bytes32))
    );
    assert_eq!(
        ::std::mem::align_of::<athcon_bytes32>(),
        1usize,
        concat!("Alignment of ", stringify!(athcon_bytes32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_bytes32),
            "::",
            stringify!(bytes)
        )
    );
}
#[doc = " The alias for athcon_bytes32 to represent a big-endian 256-bit integer."]
pub type athcon_uint256be = athcon_bytes32;
#[doc = " Big-endian 192-bit hash suitable for keeping an account address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct athcon_address {
    #[doc = " The 24 bytes of the hash."]
    pub bytes: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_athcon_address() {
    const UNINIT: ::std::mem::MaybeUninit<athcon_address> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<athcon_address>(),
        24usize,
        concat!("Size of: ", stringify!(athcon_address))
    );
    assert_eq!(
        ::std::mem::align_of::<athcon_address>(),
        1usize,
        concat!("Alignment of ", stringify!(athcon_address))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_address),
            "::",
            stringify!(bytes)
        )
    );
}
#[doc = "< Request CALL."]
pub const athcon_call_kind_ATHCON_CALL: athcon_call_kind = 0;
#[doc = " The kind of call-like instruction."]
pub type athcon_call_kind = ::std::os::raw::c_uint;
#[doc = " The message describing an Athena call, including a zero-depth calls from a transaction origin.\n\n Most of the fields are modelled by the section 8. Message Call of the Ethereum Yellow Paper."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct athcon_message {
    #[doc = " The kind of the call. For zero-depth calls ::ATHCON_CALL SHOULD be used."]
    pub kind: athcon_call_kind,
    #[doc = " The present depth of the message call stack."]
    pub depth: i32,
    #[doc = " The amount of gas available to the message execution."]
    pub gas: i64,
    #[doc = " The recipient of the message.\n\n This is the address of the account which storage/balance/nonce is going to be modified\n by the message execution. In case of ::ATHCON_CALL, this is also the account where the\n message value athcon_message::value is going to be transferred.\n For ::ATHCON_CALLCODE or ::ATHCON_DELEGATECALL, this may be different from\n the athcon_message::code_address."]
    pub recipient: athcon_address,
    #[doc = " The sender of the message.\n\n The address of the sender of a message call.\n This must be the message recipient of the message at the previous (lower) depth,\n except for the ::ATHCON_DELEGATECALL where recipient is the 2 levels above the present depth.\n At the depth 0 this must be the transaction origin."]
    pub sender: athcon_address,
    #[doc = " The message input data.\n\n The arbitrary length byte array of the input data of the call.\n This MAY be NULL."]
    pub input_data: *const u8,
    #[doc = " The size of the message input data.\n\n If input_data is NULL this MUST be 0."]
    pub input_size: usize,
    #[doc = " The number of coins transferred with the message.\n\n This is transferred value for ::ATHCON_CALL or apparent value for ::ATHCON_DELEGATECALL."]
    pub value: athcon_uint256be,
    #[doc = " The code to be executed."]
    pub code: *const u8,
    #[doc = " The length of the code to be executed."]
    pub code_size: usize,
}
#[test]
fn bindgen_test_layout_athcon_message() {
    const UNINIT: ::std::mem::MaybeUninit<athcon_message> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<athcon_message>(),
        128usize,
        concat!("Size of: ", stringify!(athcon_message))
    );
    assert_eq!(
        ::std::mem::align_of::<athcon_message>(),
        8usize,
        concat!("Alignment of ", stringify!(athcon_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_message),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_message),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gas) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_message),
            "::",
            stringify!(gas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recipient) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_message),
            "::",
            stringify!(recipient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_message),
            "::",
            stringify!(sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_message),
            "::",
            stringify!(input_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_size) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_message),
            "::",
            stringify!(input_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_message),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_message),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code_size) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_message),
            "::",
            stringify!(code_size)
        )
    );
}
#[doc = " The transaction and block data for execution."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct athcon_tx_context {
    #[doc = "< The transaction gas price."]
    pub tx_gas_price: athcon_uint256be,
    #[doc = "< The transaction origin account."]
    pub tx_origin: athcon_address,
    #[doc = "< The block height."]
    pub block_height: i64,
    #[doc = "< The block timestamp."]
    pub block_timestamp: i64,
    #[doc = "< The block gas limit."]
    pub block_gas_limit: i64,
    #[doc = "< The blockchain's ChainID."]
    pub chain_id: athcon_uint256be,
}
#[test]
fn bindgen_test_layout_athcon_tx_context() {
    const UNINIT: ::std::mem::MaybeUninit<athcon_tx_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<athcon_tx_context>(),
        112usize,
        concat!("Size of: ", stringify!(athcon_tx_context))
    );
    assert_eq!(
        ::std::mem::align_of::<athcon_tx_context>(),
        8usize,
        concat!("Alignment of ", stringify!(athcon_tx_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_gas_price) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_tx_context),
            "::",
            stringify!(tx_gas_price)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_origin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_tx_context),
            "::",
            stringify!(tx_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_height) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_tx_context),
            "::",
            stringify!(block_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_timestamp) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_tx_context),
            "::",
            stringify!(block_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_gas_limit) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_tx_context),
            "::",
            stringify!(block_gas_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain_id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_tx_context),
            "::",
            stringify!(chain_id)
        )
    );
}
#[doc = " @struct athcon_host_context\n The opaque data type representing the Host execution context.\n @see athcon_execute_fn()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct athcon_host_context {
    _unused: [u8; 0],
}
#[doc = " Get transaction context callback function.\n\n  This callback function is used by a VM to retrieve the transaction and\n  block context.\n\n  @param      context  The pointer to the Host execution context.\n  @return              The transaction context."]
pub type athcon_get_tx_context_fn = ::std::option::Option<
    unsafe extern "C" fn(context: *mut athcon_host_context) -> athcon_tx_context,
>;
#[doc = " Get block hash callback function.\n\n This callback function is used by a VM to query the hash of the header of the given block.\n If the information about the requested block is not available, then this is signalled by\n returning null bytes.\n\n @param context  The pointer to the Host execution context.\n @param number   The block height.\n @return         The block hash or null bytes\n                 if the information about the block is not available."]
pub type athcon_get_block_hash_fn = ::std::option::Option<
    unsafe extern "C" fn(context: *mut athcon_host_context, number: i64) -> athcon_bytes32,
>;
#[doc = " Execution finished with success."]
pub const athcon_status_code_ATHCON_SUCCESS: athcon_status_code = 0;
#[doc = " Generic execution failure."]
pub const athcon_status_code_ATHCON_FAILURE: athcon_status_code = 1;
#[doc = " Execution terminated with REVERT opcode.\n\n In this case the amount of gas left MAY be non-zero and additional output\n data MAY be provided in ::athcon_result."]
pub const athcon_status_code_ATHCON_REVERT: athcon_status_code = 2;
#[doc = " The execution has run out of gas."]
pub const athcon_status_code_ATHCON_OUT_OF_GAS: athcon_status_code = 3;
#[doc = " An undefined instruction has been encountered."]
pub const athcon_status_code_ATHCON_UNDEFINED_INSTRUCTION: athcon_status_code = 5;
#[doc = " Tried to read outside memory bounds.\n\n An example is RETURNDATACOPY reading past the available buffer."]
pub const athcon_status_code_ATHCON_INVALID_MEMORY_ACCESS: athcon_status_code = 9;
#[doc = " Call depth has exceeded the limit (if any)"]
pub const athcon_status_code_ATHCON_CALL_DEPTH_EXCEEDED: athcon_status_code = 10;
#[doc = " A call to a precompiled or system contract has ended with a failure.\n\n An example: elliptic curve functions handed invalid EC points."]
pub const athcon_status_code_ATHCON_PRECOMPILE_FAILURE: athcon_status_code = 12;
#[doc = " Contract validation has failed."]
pub const athcon_status_code_ATHCON_CONTRACT_VALIDATION_FAILURE: athcon_status_code = 13;
#[doc = " An argument to a state accessing method has a value outside of the\n accepted range of values."]
pub const athcon_status_code_ATHCON_ARGUMENT_OUT_OF_RANGE: athcon_status_code = 14;
#[doc = " The caller does not have enough funds for value transfer."]
pub const athcon_status_code_ATHCON_INSUFFICIENT_BALANCE: athcon_status_code = 17;
#[doc = " Athena implementation generic internal error."]
pub const athcon_status_code_ATHCON_INTERNAL_ERROR: athcon_status_code = -1;
#[doc = " The execution of the given code and/or message has been rejected\n by the Athena implementation.\n\n This error SHOULD be used to signal that the Athena is not able to or\n willing to execute the given code type or message.\n If an Athena returns the ::ATHCON_REJECTED status code,\n the Client MAY try to execute it in other Athena implementation.\n For example, the Client tries running a code in the Athena 1.5. If the\n code is not supported there, the execution falls back to the Athena 1.0."]
pub const athcon_status_code_ATHCON_REJECTED: athcon_status_code = -2;
#[doc = " The VM failed to allocate the amount of memory needed for execution."]
pub const athcon_status_code_ATHCON_OUT_OF_MEMORY: athcon_status_code = -3;
#[doc = " The execution status code.\n\n Successful execution is represented by ::ATHCON_SUCCESS having value 0.\n\n Positive values represent failures defined by VM specifications with generic\n ::ATHCON_FAILURE code of value 1.\n\n Status codes with negative values represent VM internal errors\n not provided by Athena specifications. These errors MUST not be passed back\n to the caller. They MAY be handled by the Client in predefined manner\n (see e.g. ::ATHCON_REJECTED), otherwise internal errors are not recoverable.\n The generic representant of errors is ::ATHCON_INTERNAL_ERROR but\n an Athena implementation MAY return negative status codes that are not defined\n in the ATHCON documentation."]
pub type athcon_status_code = ::std::os::raw::c_int;
#[doc = " Releases resources assigned to an execution result.\n\n This function releases memory (and other resources, if any) assigned to the\n specified execution result making the result object invalid.\n\n @param result  The execution result which resources are to be released. The\n                result itself it not modified by this function, but becomes\n                invalid and user MUST discard it as well.\n                This MUST NOT be NULL.\n\n @note\n The result is passed by pointer to avoid (shallow) copy of the ::athcon_result\n struct. Think of this as the best possible C language approximation to\n passing objects by reference."]
pub type athcon_release_result_fn =
    ::std::option::Option<unsafe extern "C" fn(result: *const athcon_result)>;
#[doc = " The Athena code execution result."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct athcon_result {
    #[doc = " The execution status code."]
    pub status_code: athcon_status_code,
    #[doc = " The amount of gas left after the execution.\n\n If athcon_result::status_code is neither ::ATHCON_SUCCESS nor ::ATHCON_REVERT\n the value MUST be 0."]
    pub gas_left: i64,
    #[doc = " The refunded gas accumulated from this execution and its sub-calls.\n\n The transaction gas refund limit is not applied.\n If athcon_result::status_code is other than ::ATHCON_SUCCESS the value MUST be 0."]
    pub gas_refund: i64,
    #[doc = " The reference to output data.\n\n The output contains data coming from RETURN opcode (iff athcon_result::code\n field is ::ATHCON_SUCCESS) or from REVERT opcode.\n\n The memory containing the output data is owned by Athena and has to be\n freed with athcon_result::release().\n\n This pointer MAY be NULL.\n If athcon_result::output_size is 0 this pointer MUST NOT be dereferenced."]
    pub output_data: *const u8,
    #[doc = " The size of the output data.\n\n If athcon_result::output_data is NULL this MUST be 0."]
    pub output_size: usize,
    #[doc = " The method releasing all resources associated with the result object.\n\n This method (function pointer) is optional (MAY be NULL) and MAY be set\n by the VM implementation. If set it MUST be called by the user once to\n release memory and other resources associated with the result object.\n Once the resources are released the result object MUST NOT be used again.\n\n The suggested code pattern for releasing execution results:\n @code\n struct athcon_result result = ...;\n if (result.release)\n     result.release(&result);\n @endcode\n\n @note\n It works similarly to C++ virtual destructor. Attaching the release\n function to the result itself allows VM composition."]
    pub release: athcon_release_result_fn,
    #[doc = " The address of the possibly created contract.\n\n The create address may be provided even though the contract creation has failed\n (athcon_result::status_code is not ::ATHCON_SUCCESS). This is useful in situations\n when the address is observable, e.g. access to it remains warm.\n In all other cases the address MUST be null bytes."]
    pub create_address: athcon_address,
}
#[test]
fn bindgen_test_layout_athcon_result() {
    const UNINIT: ::std::mem::MaybeUninit<athcon_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<athcon_result>(),
        72usize,
        concat!("Size of: ", stringify!(athcon_result))
    );
    assert_eq!(
        ::std::mem::align_of::<athcon_result>(),
        8usize,
        concat!("Alignment of ", stringify!(athcon_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_result),
            "::",
            stringify!(status_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gas_left) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_result),
            "::",
            stringify!(gas_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gas_refund) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_result),
            "::",
            stringify!(gas_refund)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_result),
            "::",
            stringify!(output_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_result),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_result),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_address) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_result),
            "::",
            stringify!(create_address)
        )
    );
}
#[doc = " Check account existence callback function.\n\n This callback function is used by the VM to check if\n there exists an account at given address.\n @param context  The pointer to the Host execution context.\n @param address  The address of the account the query is about.\n @return         true if exists, false otherwise."]
#[allow(non_camel_case_types)]
pub type athcon_account_exists_fn = ::std::option::Option<
    unsafe extern "C" fn(context: *mut athcon_host_context, address: *const athcon_address) -> bool,
>;
#[doc = " Get storage callback function.\n\n This callback function is used by a VM to query the given account storage entry.\n\n @param context  The Host execution context.\n @param address  The address of the account.\n @param key      The index of the account's storage entry.\n @return         The storage value at the given storage key or null bytes\n                 if the account does not exist."]
#[allow(non_camel_case_types)]
pub type athcon_get_storage_fn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut athcon_host_context,
        address: *const athcon_address,
        key: *const athcon_bytes32,
    ) -> athcon_bytes32,
>;
#[doc = " The new/same value is assigned to the storage item without affecting the cost structure.\n\n The storage value item is either:\n - left unchanged (c == v) or\n - the dirty value (o != c) is modified again (c != v).\n This is the group of cases related to minimal gas cost of only accessing warm storage.\n 0|X   -> 0 -> 0 (current value unchanged)\n 0|X|Y -> Y -> Y (current value unchanged)\n 0|X   -> Y -> Z (modified previously added/modified value)\n\n This is \"catch all remaining\" status. I.e. if all other statuses are correctly matched\n this status should be assigned to all remaining cases."]
pub const athcon_storage_status_ATHCON_STORAGE_ASSIGNED: athcon_storage_status = 0;
#[doc = " A new storage item is added by changing\n the current clean zero to a nonzero value.\n 0 -> 0 -> Z"]
pub const athcon_storage_status_ATHCON_STORAGE_ADDED: athcon_storage_status = 1;
#[doc = " A storage item is deleted by changing\n the current clean nonzero to the zero value.\n X -> X -> 0"]
pub const athcon_storage_status_ATHCON_STORAGE_DELETED: athcon_storage_status = 2;
#[doc = " A storage item is modified by changing\n the current clean nonzero to other nonzero value.\n X -> X -> Z"]
pub const athcon_storage_status_ATHCON_STORAGE_MODIFIED: athcon_storage_status = 3;
#[doc = " A storage item is added by changing\n the current dirty zero to a nonzero value other than the original value.\n X -> 0 -> Z"]
pub const athcon_storage_status_ATHCON_STORAGE_DELETED_ADDED: athcon_storage_status = 4;
#[doc = " A storage item is deleted by changing\n the current dirty nonzero to the zero value and the original value is not zero.\n X -> Y -> 0"]
pub const athcon_storage_status_ATHCON_STORAGE_MODIFIED_DELETED: athcon_storage_status = 5;
#[doc = " A storage item is added by changing\n the current dirty zero to the original value.\n X -> 0 -> X"]
pub const athcon_storage_status_ATHCON_STORAGE_DELETED_RESTORED: athcon_storage_status = 6;
#[doc = " A storage item is deleted by changing\n the current dirty nonzero to the original zero value.\n 0 -> Y -> 0"]
pub const athcon_storage_status_ATHCON_STORAGE_ADDED_DELETED: athcon_storage_status = 7;
#[doc = " A storage item is modified by changing\n the current dirty nonzero to the original nonzero value other than the current value.\n X -> Y -> X"]
pub const athcon_storage_status_ATHCON_STORAGE_MODIFIED_RESTORED: athcon_storage_status = 8;
#[doc = " The effect of an attempt to modify a contract storage item.\n\n See @ref storagestatus for additional information about design of this enum\n and analysis of the specification.\n\n For the purpose of explaining the meaning of each element, the following\n notation is used:\n - 0 is zero value,\n - X != 0 (X is any value other than 0),\n - Y != 0, Y != X,  (Y is any value other than X and 0),\n - Z != 0, Z != X, Z != X (Z is any value other than Y and X and 0),\n - the \"o -> c -> v\" triple describes the change status in the context of:\n   - o: original value (cold value before a transaction started),\n   - c: current storage value,\n   - v: new storage value to be set.\n\n The order of elements follows EIPs introducing net storage gas costs:\n - EIP-2200: https://eips.ethereum.org/EIPS/eip-2200,\n - EIP-1283: https://eips.ethereum.org/EIPS/eip-1283."]
pub type athcon_storage_status = ::std::os::raw::c_uint;
#[doc = " Set storage callback function.\n\n This callback function is used by a VM to update the given account storage entry.\n The VM MUST make sure that the account exists. This requirement is only a formality because\n VM implementations only modify storage of the account of the current execution context\n (i.e. referenced by athcon_message::recipient).\n\n @param context  The pointer to the Host execution context.\n @param address  The address of the account.\n @param key      The index of the storage entry.\n @param value    The value to be stored.\n @return         The effect on the storage item."]
pub type athcon_set_storage_fn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut athcon_host_context,
        address: *const athcon_address,
        key: *const athcon_bytes32,
        value: *const athcon_bytes32,
    ) -> athcon_storage_status,
>;
#[doc = " Get balance callback function.\n\n This callback function is used by a VM to query the balance of the given account.\n\n @param context  The pointer to the Host execution context.\n @param address  The address of the account.\n @return         The balance of the given account or 0 if the account does not exist."]
pub type athcon_get_balance_fn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut athcon_host_context,
        address: *const athcon_address,
    ) -> athcon_uint256be,
>;
#[doc = " Pointer to the callback function supporting Athena calls.\n\n @param context  The pointer to the Host execution context.\n @param msg      The call parameters.\n @return         The result of the call."]
pub type athcon_call_fn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut athcon_host_context,
        msg: *const athcon_message,
    ) -> athcon_result,
>;
#[doc = " The Host interface.\n\n The set of all callback functions expected by VM instances. This is C\n realisation of vtable for OOP interface (only virtual methods, no data).\n Host implementations SHOULD create constant singletons of this (similarly\n to vtables) to lower the maintenance and memory management cost."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct athcon_host_interface {
    #[doc = " Check account existence callback function."]
    pub account_exists: athcon_account_exists_fn,
    #[doc = " Get storage callback function."]
    pub get_storage: athcon_get_storage_fn,
    #[doc = " Set storage callback function."]
    pub set_storage: athcon_set_storage_fn,
    #[doc = " Get balance callback function."]
    pub get_balance: athcon_get_balance_fn,
    #[doc = " Call callback function."]
    pub call: athcon_call_fn,
    #[doc = " Get transaction context callback function."]
    pub get_tx_context: athcon_get_tx_context_fn,
    #[doc = " Get block hash callback function."]
    pub get_block_hash: athcon_get_block_hash_fn,
}
#[test]
fn bindgen_test_layout_athcon_host_interface() {
    const UNINIT: ::std::mem::MaybeUninit<athcon_host_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<athcon_host_interface>(),
        56usize,
        concat!("Size of: ", stringify!(athcon_host_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<athcon_host_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(athcon_host_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).account_exists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_host_interface),
            "::",
            stringify!(account_exists)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_storage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_host_interface),
            "::",
            stringify!(get_storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_storage) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_host_interface),
            "::",
            stringify!(set_storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_balance) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_host_interface),
            "::",
            stringify!(get_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).call) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_host_interface),
            "::",
            stringify!(call)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_tx_context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_host_interface),
            "::",
            stringify!(get_tx_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_block_hash) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_host_interface),
            "::",
            stringify!(get_block_hash)
        )
    );
}
#[doc = " Destroys the VM instance.\n\n @param vm  The VM instance to be destroyed."]
pub type athcon_destroy_fn = ::std::option::Option<unsafe extern "C" fn(vm: *mut athcon_vm)>;
pub const athcon_set_option_result_ATHCON_SET_OPTION_SUCCESS: athcon_set_option_result = 0;
pub const athcon_set_option_result_ATHCON_SET_OPTION_INVALID_NAME: athcon_set_option_result = 1;
pub const athcon_set_option_result_ATHCON_SET_OPTION_INVALID_VALUE: athcon_set_option_result = 2;
#[doc = " Possible outcomes of athcon_set_option."]
pub type athcon_set_option_result = ::std::os::raw::c_uint;
#[doc = " Configures the VM instance.\n\n Allows modifying options of the VM instance.\n Options:\n - code cache behavior: on, off, read-only, ...\n - optimizations,\n\n @param vm     The VM instance to be configured.\n @param name   The option name. NULL-terminated string. Cannot be NULL.\n @param value  The new option value. NULL-terminated string. Cannot be NULL.\n @return       The outcome of the operation."]
pub type athcon_set_option_fn = ::std::option::Option<
    unsafe extern "C" fn(
        vm: *mut athcon_vm,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> athcon_set_option_result,
>;
#[doc = " The Frontier revision."]
pub const athcon_revision_ATHCON_FRONTIER: athcon_revision = 0;
#[doc = " The maximum Athena revision supported."]
pub const athcon_revision_ATHCON_MAX_REVISION: athcon_revision = 0;
#[doc = " The latest known Athena revision with finalized specification.\n\n This is handy for Athena tools to always use the latest revision available."]
pub const athcon_revision_ATHCON_LATEST_STABLE_REVISION: athcon_revision = 0;
#[doc = " Athena revision.\n\n The revision of the Athena specification."]
pub type athcon_revision = ::std::os::raw::c_uint;
#[doc = " Executes the given code using the input from the message.\n\n This function MAY be invoked multiple times for a single VM instance.\n\n @param vm         The VM instance. This argument MUST NOT be NULL.\n @param host       The Host interface. This argument MUST NOT be NULL unless\n                   the @p vm has the ::ATHCON_CAPABILITY_PRECOMPILES capability.\n @param context    The opaque pointer to the Host execution context.\n                   This argument MAY be NULL. The VM MUST pass the same\n                   pointer to the methods of the @p host interface.\n                   The VM MUST NOT dereference the pointer.\n @param rev        The requested Athena specification revision.\n @param msg        The call parameters. See ::athcon_message. This argument MUST NOT be NULL.\n @param code       The reference to the code to be executed. This argument MAY be NULL.\n @param code_size  The length of the code. If @p code is NULL this argument MUST be 0.\n @return           The execution result."]
pub type athcon_execute_fn = ::std::option::Option<
    unsafe extern "C" fn(
        vm: *mut athcon_vm,
        host: *const athcon_host_interface,
        context: *mut athcon_host_context,
        rev: athcon_revision,
        msg: *const athcon_message,
        code: *const u8,
        code_size: usize,
    ) -> athcon_result,
>;
#[doc = " The VM is capable of executing Athena1 bytecode."]
pub const athcon_capabilities_ATHCON_CAPABILITY_Athena1: athcon_capabilities = 1;
#[doc = " Possible capabilities of a VM."]
pub type athcon_capabilities = ::std::os::raw::c_uint;
#[doc = " Alias for unsigned integer representing a set of bit flags of ATHCON capabilities.\n\n @see athcon_capabilities"]
pub type athcon_capabilities_flagset = u32;
#[doc = " Return the supported capabilities of the VM instance.\n\n This function MAY be invoked multiple times for a single VM instance,\n and its value MAY be influenced by calls to athcon_vm::set_option.\n\n @param vm  The VM instance.\n @return    The supported capabilities of the VM. @see athcon_capabilities."]
pub type athcon_get_capabilities_fn =
    ::std::option::Option<unsafe extern "C" fn(vm: *mut athcon_vm) -> athcon_capabilities_flagset>;
#[doc = " The VM instance.\n\n Defines the base struct of the VM implementation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct athcon_vm {
    #[doc = " ATHCON ABI version implemented by the VM instance.\n\n Can be used to detect ABI incompatibilities.\n The ATHCON ABI version represented by this file is in ::ATHCON_ABI_VERSION."]
    pub abi_version: ::std::os::raw::c_int,
    #[doc = " The name of the ATHCON VM implementation.\n\n It MUST be a NULL-terminated not empty string.\n The content MUST be UTF-8 encoded (this implies ASCII encoding is also allowed)."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The version of the ATHCON VM implementation, e.g. \"1.2.3b4\".\n\n It MUST be a NULL-terminated not empty string.\n The content MUST be UTF-8 encoded (this implies ASCII encoding is also allowed)."]
    pub version: *const ::std::os::raw::c_char,
    #[doc = " Pointer to function destroying the VM instance.\n\n This is a mandatory method and MUST NOT be set to NULL."]
    pub destroy: athcon_destroy_fn,
    #[doc = " Pointer to function executing a code by the VM instance.\n\n This is a mandatory method and MUST NOT be set to NULL."]
    pub execute: athcon_execute_fn,
    #[doc = " A method returning capabilities supported by the VM instance.\n\n The value returned MAY change when different options are set via the set_option() method.\n\n A Client SHOULD only rely on the value returned if it has queried it after\n it has called the set_option().\n\n This is a mandatory method and MUST NOT be set to NULL."]
    pub get_capabilities: athcon_get_capabilities_fn,
    #[doc = " Optional pointer to function modifying VM's options.\n\n If the VM does not support this feature the pointer can be NULL."]
    pub set_option: athcon_set_option_fn,
}
#[test]
fn bindgen_test_layout_athcon_vm() {
    const UNINIT: ::std::mem::MaybeUninit<athcon_vm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<athcon_vm>(),
        56usize,
        concat!("Size of: ", stringify!(athcon_vm))
    );
    assert_eq!(
        ::std::mem::align_of::<athcon_vm>(),
        8usize,
        concat!("Alignment of ", stringify!(athcon_vm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abi_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_vm),
            "::",
            stringify!(abi_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_vm),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_vm),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_vm),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).execute) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_vm),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_capabilities) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_vm),
            "::",
            stringify!(get_capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_option) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(athcon_vm),
            "::",
            stringify!(set_option)
        )
    );
}
